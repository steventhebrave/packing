<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Don't Break the Chain</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet" />

  <style>
    body {
      font-family: "Inter", system-ui, sans-serif;
    }

    .chain-cell {
      transition: all 0.2s ease;
      cursor: pointer;
      user-select: none;
    }

    .chain-cell:hover {
      transform: scale(1.1);
    }

    .chain-cell svg {
      transition: all 0.2s ease;
    }
  </style>
</head>

<body class="bg-slate-100 dark:bg-gray-900 text-slate-800 dark:text-slate-200 min-h-screen p-4 md:p-8">

  <main class="max-w-4xl mx-auto">
    <header class="mb-4 text-center relative">
      <div id="status-indicator" class="absolute top-0 right-0 w-3 h-3 rounded-full bg-gray-300" title="Connecting...">
      </div>
      <h1 class="text-xl font-bold text-slate-900 dark:text-white mb-1">Don't Break the Chain</h1>
      <p class="text-sm text-gray-600 dark:text-gray-400">Track daily progress with your accountability buddies</p>
    </header>

    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-x-auto">
      <table class="w-full">
        <thead>
          <tr class="border-b-2 border-gray-200 dark:border-gray-700">
            <th class="p-3 text-left text-sm font-semibold text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800">
              Date</th>
            <th id="participant-1"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
            <th id="participant-2"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
            <th id="participant-3"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
            <th id="participant-4"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
          </tr>
        </thead>
        <tbody id="chain-grid">
          <!-- Grid will be generated here -->
        </tbody>
      </table>
    </div>

    <footer class="mt-8 text-center">
      <p class="text-xs text-gray-500">Share this page's URL to collaborate in real-time!</p>
    </footer>
  </main>

  <script type="module">
    import * as Y from "https://jspm.dev/yjs";
    import { WebsocketProvider } from "https://jspm.dev/y-websocket";

    // --- CONFIGURATION ---
    const SERVER_URL = "wss://packing-list-realtime.fly.dev";
    const START_DATE = new Date(2026, 1, 18); // Oct 27, 2025 (month is 0-indexed)
    const NUM_WEEKS = 8;
    const NUM_DAYS = NUM_WEEKS * 7;
    const PARTICIPANTS = ['P1', 'P2', 'P3', 'P4'];

    /**
     * Gets the room name from the URL hash.
     * If no hash is present, it generates a new random one and updates the URL.
     */
    function getRoomNameFromUrl() {
      if (window.location.hash) {
        return window.location.hash.substring(1);
      } else {
        const newRoom = 'chain-' + crypto.randomUUID().split('-')[0];
        window.location.hash = newRoom;
        return newRoom;
      }
    }

    /**
     * Gets the locked participant index from URL parameter ?p=X
     * Returns null if no lock, or the participant index (0-3) if locked
     */
    function getLockedParticipant() {
      const params = new URLSearchParams(window.location.search);
      const p = params.get('p');
      if (p !== null) {
        const participantNum = parseInt(p, 10);
        // Convert 1-4 to 0-3 index, validate range
        if (participantNum >= 1 && participantNum <= PARTICIPANTS.length) {
          return participantNum - 1;
        }
      }
      return null;
    }

    const ROOM_NAME = getRoomNameFromUrl();
    const LOCKED_PARTICIPANT = getLockedParticipant();

    // --- YJS SETUP ---
    const doc = new Y.Doc();
    const provider = new WebsocketProvider(SERVER_URL, ROOM_NAME, doc);

    // Shared data types
    const chainData = doc.getMap("chainData"); // Map of "date-participant" -> status ("check" | "cross" | null)
    const chainImages = doc.getMap("chainImages"); // Map of "date-participant" -> image URL
    const participantNames = doc.getMap("participantNames"); // Map of participant index -> custom name

    // Track if we've synced initial data
    let isInitialSyncComplete = false;

    // --- DOM ELEMENTS ---
    const statusEl = document.getElementById("status-indicator");
    const chainGridEl = document.getElementById("chain-grid");
    const participantHeaders = [
      document.getElementById("participant-1"),
      document.getElementById("participant-2"),
      document.getElementById("participant-3"),
      document.getElementById("participant-4")
    ];

    // --- HELPER FUNCTIONS ---

    /**
     * Compresses and resizes an image file to a maximum dimension.
     * @param {File} file - The image file to compress.
     * @param {number} maxWidth - Max width/height.
     * @param {number} quality - JPEG quality (0-1).
     * @returns {Promise<Blob>} - Compressed blob.
     */
    async function compressImage(file, maxWidth = 1280, quality = 0.8) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (event) => {
          const img = new Image();
          img.src = event.target.result;
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;

            // Resize logic
            if (width > height) {
              if (width > maxWidth) {
                height *= maxWidth / width;
                width = maxWidth;
              }
            } else {
              if (height > maxWidth) {
                width *= maxWidth / height;
                height = maxWidth;
              }
            }

            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);

            canvas.toBlob((blob) => {
              resolve(blob);
            }, 'image/jpeg', quality);
          };
          img.onerror = (err) => reject(err);
        };
        reader.onerror = (err) => reject(err);
      });
    }

    async function uploadImage(file, dateKey, participantIndex) {
      statusEl.className = 'absolute top-0 right-0 w-3 h-3 rounded-full bg-blue-500 animate-pulse'; // Uploading state

      try {
        const compressedBlob = await compressImage(file);

        // Create form data
        const formData = new FormData();
        // Append with a filename that ends in .jpg
        formData.append('image', compressedBlob, 'upload.jpg');

        // Note: Using the HTTP endpoint of the same server
        // Use relative path if hosting on same origin, or construct full URL
        let uploadUrl = '/upload';

        // Handle dev environment (if SERVER_URL is different origin)
        if (SERVER_URL.startsWith('http') || SERVER_URL.startsWith('ws')) {
          const url = new URL(SERVER_URL);
          const protocol = url.protocol === 'wss:' ? 'https:' : 'http:';
          uploadUrl = `${protocol}//${url.host}/upload`;
        }

        const response = await fetch(uploadUrl, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) throw new Error('Upload failed');

        const data = await response.json();
        const imageUrl = data.url;

        // Save to Yjs
        doc.transact(() => {
          const key = getCellKey(dateKey, participantIndex);
          chainImages.set(key, imageUrl);
        });

        // Reset status
        updateStatusUI(provider.status);

      } catch (e) {
        console.error("Upload error", e);
        statusEl.className = 'absolute top-0 right-0 w-3 h-3 rounded-full bg-red-500';
        setTimeout(() => updateStatusUI(provider.status), 2000);
        alert("Failed to upload image. Please try again.");
      }
    }

    // Hidden file input for handling uploads
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);

    // Global handler state
    let currentUploadTarget = null; // { dateKey, participantIndex }

    fileInput.addEventListener('change', (e) => {
      if (e.target.files && e.target.files[0] && currentUploadTarget) {
        uploadImage(e.target.files[0], currentUploadTarget.dateKey, currentUploadTarget.participantIndex);
      }
      // Reset
      fileInput.value = '';
      currentUploadTarget = null;
    });

    function triggerUpload(dateKey, participantIndex) {
      currentUploadTarget = { dateKey, participantIndex };
      fileInput.click();
    }

    function formatDate(date) {
      const day = date.getDate();
      const month = date.toLocaleDateString('en-US', { month: 'short' });
      return `${day} ${month}`;
    }

    function getDateKey(date) {
      return date.toISOString().split('T')[0]; // YYYY-MM-DD
    }

    function getCellKey(dateKey, participantIndex) {
      return `${dateKey}-${participantIndex}`;
    }

    function getCellStatus(dateKey, participantIndex) {
      return chainData.get(getCellKey(dateKey, participantIndex)) || null;
    }

    function getCellImage(dateKey, participantIndex) {
      const key = getCellKey(dateKey, participantIndex);
      return chainImages.get(key) || null;
    }

    function setCellStatus(dateKey, participantIndex, status) {
      const key = getCellKey(dateKey, participantIndex);
      if (status === null) {
        chainData.delete(key);
      } else {
        chainData.set(key, status);
      }
    }

    function cycleCellStatus(dateKey, participantIndex) {
      const current = getCellStatus(dateKey, participantIndex);
      const next = current === null ? 'check' : current === 'check' ? 'cross' : null;

      doc.transact(() => {
        setCellStatus(dateKey, participantIndex, next);
      });
    }

    // --- RENDERING ---

    function renderSkeleton() {
      chainGridEl.innerHTML = '';

      for (let i = 0; i < 10; i++) { // Show 10 skeleton rows
        const row = document.createElement('tr');
        row.className = 'animate-pulse';

        // Date column skeleton
        const dateCell = document.createElement('td');
        dateCell.className = 'p-3 bg-white dark:bg-gray-800 border-b border-gray-100 dark:border-gray-700';
        dateCell.innerHTML = '<div class="h-4 w-16 bg-gray-300 dark:bg-gray-600 rounded"></div>';
        row.appendChild(dateCell);

        // Participant column skeletons
        for (let j = 0; j < PARTICIPANTS.length; j++) {
          const cell = document.createElement('td');
          cell.className = 'p-3 text-center border-b border-gray-100 dark:border-gray-700';
          cell.innerHTML = '<div class="inline-block w-8 h-8 bg-gray-300 dark:bg-gray-600 rounded-full"></div>';
          row.appendChild(cell);
        }

        chainGridEl.appendChild(row);
      }
    }

    function renderCell(status, imageUrl, isCompact) {
      const cell = document.createElement('td');
      cell.className = 'chain-cell text-center border-b border-gray-100 dark:border-gray-700 relative'; // Relative for positioning image

      if (isCompact) {
        cell.className += ' p-[2px]'; // Ultra reduced padding
        let dotColor = 'bg-gray-200 dark:bg-gray-700';

        if (status === 'check') {
          dotColor = 'bg-green-500';
        } else if (status === 'cross') {
          dotColor = 'bg-red-500';
        }

        let content = `<div class="inline-block w-3 h-3 rounded-full ${dotColor}"></div>`;

        // Indicator for image presence in compact mode
        if (imageUrl) {
          content += `<div class="absolute bottom-[2px] right-[2px] w-1.5 h-1.5 bg-blue-400 rounded-full border border-white dark:border-gray-800"></div>`;
        }

        cell.innerHTML = content;

      } else {
        cell.className += ' p-3'; // Normal padding

        let inner = '';

        if (imageUrl) {
          // Build the image URL.
          // If absolute path from other domain, fine. If relative, needs base if testing locally against remote
          let src = imageUrl;
          if (SERVER_URL.startsWith('wss') && !imageUrl.startsWith('http')) {
            const url = new URL(SERVER_URL);
            const protocol = 'https:';
            src = `${protocol}//${url.host}${imageUrl}`;
          }

          inner = `
               <div class="group relative inline-block">
                 <img src="${src}" class="w-8 h-8 rounded-full object-cover border-2 border-green-500" alt="Proof" />
                 <div class="absolute inset-0 bg-black/50 rounded-full opacity-0 group-hover:opacity-100 flex items-center justify-center transition-opacity">
                      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
                 </div>
               </div>
             `;
        } else if (status === 'check') {
          inner = `
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="inline-block text-green-500">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
          `;
        } else if (status === 'cross') {
          inner = `
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="inline-block text-red-500">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          `;
        } else {
          inner = `
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block text-gray-300 dark:text-gray-600">
              <circle cx="12" cy="12" r="10"></circle>
            </svg>
          `;
        }
        cell.innerHTML = inner;
      }

      return cell;
    }

    function renderGrid() {
      // Don't render real data until we've synced
      if (!isInitialSyncComplete) return;

      chainGridEl.innerHTML = '';

      // Get today's date in local time (no time component)
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Calculate cutoff date (2 days ago)
      const cutoffDate = new Date(today);
      cutoffDate.setDate(today.getDate() - 2);

      for (let i = 0; i < NUM_DAYS; i++) {
        const currentDate = new Date(START_DATE);
        currentDate.setDate(START_DATE.getDate() + i);
        const dateKey = getDateKey(currentDate);

        // Check if this is today
        const dateOnly = new Date(currentDate);
        dateOnly.setHours(0, 0, 0, 0);
        const isToday = dateOnly.getTime() === today.getTime();

        // Check if weekend (Saturday = 6, Sunday = 0)
        const dayOfWeek = currentDate.getDay();
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

        // Check if compact (older than 2 days)
        // We compare timestamps to be safe
        const isCompact = dateOnly.getTime() < cutoffDate.getTime();

        const row = document.createElement('tr');
        let rowClasses = 'hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors';

        // Add weekend styling
        if (isWeekend) {
          rowClasses = 'bg-blue-50/30 dark:bg-blue-900/10 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-colors';
        }

        // Add today highlighting (stronger)
        if (isToday) {
          rowClasses = 'bg-yellow-100 dark:bg-yellow-900/30 hover:bg-yellow-200 dark:hover:bg-yellow-900/40 transition-colors ring-2 ring-yellow-400 dark:ring-yellow-600';
        }

        row.className = rowClasses;

        // Date column
        const dateCell = document.createElement('td');
        let dateCellClasses = 'text-sm font-medium text-gray-600 dark:text-gray-400 border-b border-gray-100 dark:border-gray-700';

        if (isCompact) {
          dateCellClasses += ' p-[2px] text-[10px] leading-none'; // Ultra compact
        } else {
          dateCellClasses += ' p-3'; // Normal padding
        }

        // Match the row background
        if (isWeekend) {
          dateCellClasses += ' bg-blue-50/30 dark:bg-blue-900/10';
        }

        if (isToday) {
          dateCellClasses = 'p-3 text-sm font-bold text-yellow-900 dark:text-yellow-200 bg-yellow-100 dark:bg-yellow-900/30 border-b border-gray-100 dark:border-gray-700';
        }

        dateCell.className = dateCellClasses;
        dateCell.textContent = formatDate(currentDate);
        row.appendChild(dateCell);

        // Participant columns
        for (let participantIndex = 0; participantIndex < PARTICIPANTS.length; participantIndex++) {
          const status = getCellStatus(dateKey, participantIndex);
          const imageUrl = getCellImage(dateKey, participantIndex);
          const cell = renderCell(status, imageUrl, isCompact);

          // Check if this cell is editable
          const isEditable = LOCKED_PARTICIPANT === null || LOCKED_PARTICIPANT === participantIndex;

          if (isEditable) {
            // Normal click to cycle status
            cell.onclick = (e) => {
              // If clicking an existing image, maybe show full size? For now just cycle status underneath
              cycleCellStatus(dateKey, participantIndex);
            };

            // Right click/Long press to upload
            cell.oncontextmenu = (e) => {
              e.preventDefault();
              triggerUpload(dateKey, participantIndex);
            };

          } else {
            // Disable interaction for locked cells
            cell.className = cell.className.replace('cursor-pointer', 'cursor-not-allowed opacity-50');
            cell.onclick = null;
          }

          row.appendChild(cell);
        }

        chainGridEl.appendChild(row);
      }
    }

    function renderParticipantNames() {
      // Don't render real names until we've synced
      if (!isInitialSyncComplete) return;

      participantHeaders.forEach((header, index) => {
        // Get saved name or default
        const savedName = participantNames.get(`p${index}`);
        const displayName = savedName || PARTICIPANTS[index];

        header.textContent = displayName;

        // Remove skeleton styling
        header.className = header.className.replace(' animate-pulse', '');

        // Set up editability based on lock
        const canEdit = LOCKED_PARTICIPANT === null || LOCKED_PARTICIPANT === index;
        header.contentEditable = canEdit ? 'true' : 'false';
      });
    }

    // --- STATUS UI ---

    function updateStatusUI(status) {
      let title = status;
      let colorClasses = '';

      switch (status) {
        case 'connected':
          title = 'Connected';
          colorClasses = 'bg-green-500';
          break;
        case 'disconnected':
          title = 'Disconnected';
          colorClasses = 'bg-yellow-500';
          break;
        case 'offline':
          title = 'Offline';
          colorClasses = 'bg-gray-400';
          break;
        default:
          title = 'Connectingâ€¦';
          colorClasses = 'bg-yellow-500';
      }

      statusEl.title = title;
      statusEl.className = `absolute top-0 right-0 w-3 h-3 rounded-full transition-colors ${colorClasses}`;
    }

    // --- EVENT LISTENERS ---

    // Handle initial sync
    provider.on('sync', synced => {
      if (synced && !isInitialSyncComplete) {
        isInitialSyncComplete = true;
        renderGrid();
        renderParticipantNames();
      }
    });

    provider.on("status", e => {
      if (navigator.onLine) {
        updateStatusUI(e.status);
      }
    });

    window.addEventListener('offline', () => updateStatusUI('offline'));
    window.addEventListener('online', () => updateStatusUI(provider.status || 'connecting'));

    updateStatusUI(navigator.onLine ? provider.status || 'connecting' : 'offline');

    // Save participant names when edited (only allow editing if not locked or if it's your column)
    participantHeaders.forEach((header, index) => {
      const canEdit = LOCKED_PARTICIPANT === null || LOCKED_PARTICIPANT === index;

      if (!canEdit) {
        header.contentEditable = 'false';
        header.className = header.className + ' opacity-50 cursor-not-allowed';
      } else {
        header.addEventListener('blur', () => {
          const newName = header.textContent.trim();
          if (newName && newName !== PARTICIPANTS[index]) {
            doc.transact(() => {
              participantNames.set(`p${index}`, newName);
            });
          }
        });

        // Prevent newlines in contenteditable
        header.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            header.blur();
          }
        });
      }
    });

    // --- YJS OBSERVERS ---

    chainData.observe(() => {
      if (isInitialSyncComplete) renderGrid();
    });

    chainImages.observe(() => {
      if (isInitialSyncComplete) renderGrid();
    });

    participantNames.observe(() => {
      if (isInitialSyncComplete) renderParticipantNames();
    });

    // Initial render - show skeleton
    renderSkeleton();

  </script>
</body>

</html>