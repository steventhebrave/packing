<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Don't Break the Chain</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet" />

  <style>
    body {
      font-family: "Inter", system-ui, sans-serif;
    }

    .chain-cell {
      transition: all 0.2s ease;
      cursor: pointer;
      user-select: none;
    }

    .chain-cell:hover {
      transform: scale(1.1);
    }

    .chain-cell svg {
      transition: all 0.2s ease;
    }

    /* Popup Animation */
    @keyframes popIn {
      0% {
        opacity: 0;
        transform: translate(-50%, 10px) scale(0.9);
      }

      100% {
        opacity: 1;
        transform: translate(-50%, 0) scale(1);
      }
    }

    /* Spinner Animation */
    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Modal Animation (Centered) */
    @keyframes popInModal {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
      }

      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    .spinner {
      animation: spin 1s linear infinite;
    }
  </style>
</head>

<body class="bg-slate-100 dark:bg-gray-900 text-slate-800 dark:text-slate-200 min-h-screen p-4 md:p-8">

  <main class="max-w-4xl mx-auto">
    <header class="mb-4 text-center relative">
      <div id="status-indicator" class="absolute top-0 right-0 w-3 h-3 rounded-full bg-gray-300" title="Connecting...">
      </div>
      <h1 class="text-xl font-bold text-slate-900 dark:text-white mb-1">Don't Break the Chain</h1>
      <p class="text-sm text-gray-600 dark:text-gray-400">Track daily progress with your accountability buddies</p>
    </header>

    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-x-auto">
      <table class="w-full">
        <thead>
          <tr class="border-b-2 border-gray-200 dark:border-gray-700">
            <th class="p-3 text-left text-sm font-semibold text-gray-500 dark:text-gray-400 bg-white dark:bg-gray-800">
              Date</th>
            <th id="participant-1"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
            <th id="participant-2"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
            <th id="participant-3"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
            <th id="participant-4"
              class="p-3 text-center text-lg font-bold text-slate-900 dark:text-white animate-pulse"
              contenteditable="false">...</th>
          </tr>
        </thead>
        <tbody id="chain-grid">
          <!-- Grid will be generated here -->
        </tbody>
      </table>
    </div>

    <footer class="mt-8 text-center">
      <p class="text-xs text-gray-500">Share this page's URL to collaborate in real-time!</p>
    </footer>
  </main>

  <!-- Unified Action Popup -->
  <div id="action-popup"
    class="hidden fixed z-50 bg-white dark:bg-gray-800 rounded-xl shadow-xl border border-gray-200 dark:border-gray-700 flex flex-col items-center gap-2 transition-all duration-200"
    style="display: none;">

    <!-- Arrow (Only shown in bubble mode) -->
    <div id="popup-arrow"
      class="absolute bottom-[-6px] left-1/2 transform -translate-x-1/2 w-3 h-3 bg-white dark:bg-gray-800 border-b border-r border-gray-200 dark:border-gray-700 rotate-45">
    </div>

    <!-- Image Container (Only shown in image mode) -->
    <div id="popup-image-container" class="hidden w-full p-2 pb-0">
      <img id="popup-img" src=""
        class="w-full h-auto max-h-[60vh] object-contain rounded-lg border border-gray-100 dark:border-gray-700" />
    </div>

    <!-- Actions -->
    <div id="popup-actions" class="flex gap-2 p-2">
      <button id="btn-check"
        class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-green-500 transition-colors"
        title="Complete (Change Photo)">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
        </svg>
      </button>
      <button id="btn-cross"
        class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-red-500 transition-colors" title="Missed">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
      <button id="btn-clear"
        class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-400 transition-colors" title="Clear">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>
        </svg>
      </button>
    </div>
  </div>

  </main>

  <script type="module">
    import * as Y from "https://jspm.dev/yjs";
    import { WebsocketProvider } from "https://jspm.dev/y-websocket";

    // --- CONFIGURATION ---
    const SERVER_URL = "wss://packing-list-realtime.fly.dev";
    const START_DATE = new Date(2026, 1, 18); // Oct 27, 2025 (month is 0-indexed)
    const NUM_WEEKS = 8;
    const NUM_DAYS = NUM_WEEKS * 7;
    const PARTICIPANTS = ['P1', 'P2', 'P3', 'P4'];

    /**
     * Gets the room name from the URL hash.
     * If no hash is present, it generates a new random one and updates the URL.
     */
    function getRoomNameFromUrl() {
      if (window.location.hash) {
        return window.location.hash.substring(1);
      } else {
        const newRoom = 'chain-' + crypto.randomUUID().split('-')[0];
        window.location.hash = newRoom;
        return newRoom;
      }
    }

    /**
     * Gets the locked participant index from URL parameter ?p=X
     * Returns null if no lock, or the participant index (0-3) if locked
     */
    function getLockedParticipant() {
      const params = new URLSearchParams(window.location.search);
      const p = params.get('p');
      if (p !== null) {
        const participantNum = parseInt(p, 10);
        // Convert 1-4 to 0-3 index, validate range
        if (participantNum >= 1 && participantNum <= PARTICIPANTS.length) {
          return participantNum - 1;
        }
      }
      return null;
    }

    const ROOM_NAME = getRoomNameFromUrl();
    const LOCKED_PARTICIPANT = getLockedParticipant();

    // --- YJS SETUP ---
    const doc = new Y.Doc();
    const provider = new WebsocketProvider(SERVER_URL, ROOM_NAME, doc);

    // Shared data types
    const chainData = doc.getMap("chainData"); // Map of "date-participant" -> status ("check" | "cross" | null)
    const chainImages = doc.getMap("chainImages"); // Map of "date-participant" -> image URL
    const participantNames = doc.getMap("participantNames"); // Map of participant index -> custom name

    // Track if we've synced initial data
    let isInitialSyncComplete = false;

    // Track local uploads: Set of "date-participant" keys
    const uploadingCells = new Set();

    // --- DOM ELEMENTS ---
    const statusEl = document.getElementById("status-indicator");
    const chainGridEl = document.getElementById("chain-grid");
    const participantHeaders = [
      document.getElementById("participant-1"),
      document.getElementById("participant-2"),
      document.getElementById("participant-3"),
      document.getElementById("participant-4")
    ];

    // Popup Elements
    const popupEl = document.getElementById("action-popup");
    const popupArrow = document.getElementById("popup-arrow");
    const popupImageContainer = document.getElementById("popup-image-container");
    const popupImg = document.getElementById("popup-img");
    const popupActions = document.getElementById("popup-actions");

    const btnCheck = document.getElementById("btn-check");
    const btnCross = document.getElementById("btn-cross");
    const btnClear = document.getElementById("btn-clear");


    // --- HELPER FUNCTIONS ---

    /**
     * Compresses and resizes an image file to a maximum dimension.
     * @param {File} file - The image file to compress.
     * @param {number} maxWidth - Max width/height.
     * @param {number} quality - JPEG quality (0-1).
     * @returns {Promise<Blob>} - Compressed blob.
     */
    async function compressImage(file, maxWidth = 1280, quality = 0.8) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = (event) => {
          const img = new Image();
          img.src = event.target.result;
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;

            // Resize logic
            if (width > height) {
              if (width > maxWidth) {
                height *= maxWidth / width;
                width = maxWidth;
              }
            } else {
              if (height > maxWidth) {
                width *= maxWidth / height;
                height = maxWidth;
              }
            }

            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);

            canvas.toBlob((blob) => {
              resolve(blob);
            }, 'image/jpeg', quality);
          };
          img.onerror = (err) => reject(err);
        };
        reader.onerror = (err) => reject(err);
      });
    }

    async function uploadImage(file, dateKey, participantIndex) {
      statusEl.className = 'absolute top-0 right-0 w-3 h-3 rounded-full bg-blue-500 animate-pulse'; // Uploading state

      const key = getCellKey(dateKey, participantIndex);
      // Set uploading state locally
      uploadingCells.add(key);
      renderGrid(); // Re-render to show spinner

      try {
        const compressedBlob = await compressImage(file);

        // Create form data
        const formData = new FormData();
        // Append with a filename that ends in .jpg
        formData.append('image', compressedBlob, 'upload.jpg');

        // Note: Using the HTTP endpoint of the same server
        // Use relative path if hosting on same origin, or construct full URL
        let uploadUrl = '/upload';

        // Handle dev environment (if SERVER_URL is different origin)
        if (SERVER_URL.startsWith('http') || SERVER_URL.startsWith('ws')) {
          const url = new URL(SERVER_URL);
          const protocol = url.protocol === 'wss:' ? 'https:' : 'http:';
          uploadUrl = `${protocol}//${url.host}/upload`;
        }

        const response = await fetch(uploadUrl, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) throw new Error('Upload failed');

        const data = await response.json();
        const imageUrl = data.url;

        // Save to Yjs
        doc.transact(() => {
          const key = getCellKey(dateKey, participantIndex);
          chainImages.set(key, imageUrl);
          // Also set status to check
          chainData.set(key, 'check');
        });

        // Reset status
        updateStatusUI(provider.status);

      } catch (e) {
        console.error("Upload error", e);
        statusEl.className = 'absolute top-0 right-0 w-3 h-3 rounded-full bg-red-500';
        setTimeout(() => updateStatusUI(provider.status), 2000);
        alert("Failed to upload image. Please try again.");
      } finally {
        // Clear uploading state
        uploadingCells.delete(key);
        renderGrid();
      }
    }

    // Hidden file input for handling uploads
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);

    // Global handler state
    let activeCellTarget = null; // { dateKey, participantIndex, element } (For Popup)
    let pendingUploadTarget = null; // { dateKey, participantIndex } (For Upload)

    fileInput.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent closing popup immediately
    });

    fileInput.addEventListener('change', (e) => {
      if (e.target.files && e.target.files[0] && pendingUploadTarget) {
        uploadImage(e.target.files[0], pendingUploadTarget.dateKey, pendingUploadTarget.participantIndex);
      }
      // Reset
      fileInput.value = '';
      hidePopup();
      pendingUploadTarget = null;
    });

    function showPopup(element, dateKey, participantIndex) {
      activeCellTarget = { dateKey, participantIndex, element };

      const existingImage = getCellImage(dateKey, participantIndex);
      const isEditable = LOCKED_PARTICIPANT === null || LOCKED_PARTICIPANT === participantIndex;

      // Show/Hide Actions based on permissions
      if (isEditable) {
        popupActions.classList.remove('hidden');
        popupActions.style.display = 'flex';
      } else {
        popupActions.classList.add('hidden');
        popupActions.style.display = 'none';
      }

      popupEl.style.display = 'flex';

      if (existingImage) {
        // --- IMAGE MODE (Centered Card) ---
        popupImageContainer.classList.remove('hidden');

        // Build absolute URL if needed
        let src = existingImage;
        if (SERVER_URL.startsWith('wss') && !existingImage.startsWith('http')) {
          const url = new URL(SERVER_URL);
          const protocol = 'https:';
          src = `${protocol}//${url.host}${existingImage}`;
        }

        popupImg.src = src;
        popupArrow.classList.add('hidden');

        // Styling for big card
        popupEl.classList.remove('p-2');
        popupEl.className = "fixed z-50 bg-white dark:bg-gray-800 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700 flex flex-col items-center gap-2 w-[90vw] max-w-md top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2";

        // Reset manual positioning
        popupEl.style.top = '50%';
        popupEl.style.left = '50%';

      } else {
        // --- BUBBLE MODE (Small Tooltip) ---
        popupImageContainer.classList.add('hidden');
        popupImg.src = '';
        popupArrow.classList.remove('hidden');

        // Styling for bubble
        popupEl.className = "fixed z-50 bg-white dark:bg-gray-800 rounded-xl shadow-xl border border-gray-200 dark:border-gray-700 p-2 flex gap-2 items-center transform -translate-x-1/2";

        // Position popup above the element
        const rect = element.getBoundingClientRect();
        const popupHeight = 60;

        popupEl.style.top = `${rect.top + window.scrollY - popupHeight}px`;
        popupEl.style.left = `${rect.left + window.scrollX + (rect.width / 2)}px`;
      }

      // Animation (Selected based on mode)
      popupEl.style.animation = 'none';
      popupEl.offsetHeight; /* trigger reflow */

      if (existingImage) {
        popupEl.style.animation = 'popInModal 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
      } else {
        popupEl.style.animation = 'popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards';
      }
    }

    function hidePopup() {
      popupEl.style.display = 'none';
      activeCellTarget = null;
    }

    // Popup Button Actions
    btnCheck.onclick = (e) => {
      e.stopPropagation();
      if (activeCellTarget) {
        // Trigger upload
        pendingUploadTarget = { ...activeCellTarget };
        fileInput.click();
      }
    };

    btnCross.onclick = (e) => {
      e.stopPropagation();
      if (activeCellTarget) {
        doc.transact(() => {
          setCellStatus(activeCellTarget.dateKey, activeCellTarget.participantIndex, 'cross');
          // Also remove image so the cross prevents the image from showing
          const key = getCellKey(activeCellTarget.dateKey, activeCellTarget.participantIndex);
          chainImages.delete(key);
        });
        hidePopup();
      }
    };

    btnClear.onclick = (e) => {
      e.stopPropagation();
      if (activeCellTarget) {
        doc.transact(() => {
          setCellStatus(activeCellTarget.dateKey, activeCellTarget.participantIndex, null);
          // Also remove image if clearing? optional, but safer
          const key = getCellKey(activeCellTarget.dateKey, activeCellTarget.participantIndex);
          chainImages.delete(key);
        });
        hidePopup();
      }
    };

    // Close popup when clicking anywhere else
    document.addEventListener('click', (e) => {
      if (!popupEl.contains(e.target) && (!activeCellTarget || !activeCellTarget.element.contains(e.target))) {
        hidePopup();
      }
    });

    function formatDate(date) {
      const day = date.getDate();
      const month = date.toLocaleDateString('en-US', { month: 'short' });
      return `${day} ${month}`;
    }

    function getDateKey(date) {
      return date.toISOString().split('T')[0]; // YYYY-MM-DD
    }

    function getCellKey(dateKey, participantIndex) {
      return `${dateKey}-${participantIndex}`;
    }

    function getCellStatus(dateKey, participantIndex) {
      return chainData.get(getCellKey(dateKey, participantIndex)) || null;
    }

    function getCellImage(dateKey, participantIndex) {
      const key = getCellKey(dateKey, participantIndex);
      return chainImages.get(key) || null;
    }

    function setCellStatus(dateKey, participantIndex, status) {
      const key = getCellKey(dateKey, participantIndex);
      if (status === null) {
        chainData.delete(key);
      } else {
        chainData.set(key, status);
      }
    }

    function cycleCellStatus(dateKey, participantIndex) {
      const current = getCellStatus(dateKey, participantIndex);
      const next = current === null ? 'check' : current === 'check' ? 'cross' : null;

      doc.transact(() => {
        setCellStatus(dateKey, participantIndex, next);
      });
    }

    // --- RENDERING ---

    function renderSkeleton() {
      chainGridEl.innerHTML = '';

      for (let i = 0; i < 10; i++) { // Show 10 skeleton rows
        const row = document.createElement('tr');
        row.className = 'animate-pulse';

        // Date column skeleton
        const dateCell = document.createElement('td');
        dateCell.className = 'p-3 bg-white dark:bg-gray-800 border-b border-gray-100 dark:border-gray-700';
        dateCell.innerHTML = '<div class="h-4 w-16 bg-gray-300 dark:bg-gray-600 rounded"></div>';
        row.appendChild(dateCell);

        // Participant column skeletons
        for (let j = 0; j < PARTICIPANTS.length; j++) {
          const cell = document.createElement('td');
          cell.className = 'p-3 text-center border-b border-gray-100 dark:border-gray-700';
          cell.innerHTML = '<div class="inline-block w-8 h-8 bg-gray-300 dark:bg-gray-600 rounded-full"></div>';
          row.appendChild(cell);
        }

        chainGridEl.appendChild(row);
      }
    }

    function renderCell(status, imageUrl, isCompact, isUploading) {
      const cell = document.createElement('td');
      cell.className = 'chain-cell text-center border-b border-gray-100 dark:border-gray-700 relative'; // Relative for positioning image

      if (isUploading) {
        cell.innerHTML = `
            <div class="inline-block w-7 h-7 rounded-full border-4 border-gray-200 border-t-blue-500 spinner align-middle"></div>
         `;
        if (isCompact) {
          cell.className += ' p-[2px]';
          cell.innerHTML = `<div class="inline-block w-3 h-3 rounded-full border-2 border-gray-200 border-t-blue-500 spinner"></div>`;
        } else {
          cell.className += ' p-3';
        }
        return cell;
      }

      if (isCompact) {
        cell.className += ' p-[2px]'; // Ultra reduced padding
        let dotColor = 'bg-gray-200 dark:bg-gray-700';

        if (status === 'check') {
          dotColor = 'bg-green-500';
        } else if (status === 'cross') {
          dotColor = 'bg-red-500';
        }

        let content = `<div class="inline-block w-3 h-3 rounded-full ${dotColor}"></div>`;

        // Indicator for image presence in compact mode
        if (imageUrl) {
          content += `<div class="absolute bottom-[2px] right-[2px] w-1.5 h-1.5 bg-blue-400 rounded-full border border-white dark:border-gray-800"></div>`;
        }

        cell.innerHTML = content;

      } else {
        cell.className += ' p-3'; // Normal padding

        let inner = '';

        if (imageUrl) {
          // Build the image URL.
          // If absolute path from other domain, fine. If relative, needs base if testing locally against remote
          let src = imageUrl;
          if (SERVER_URL.startsWith('wss') && !imageUrl.startsWith('http')) {
            const url = new URL(SERVER_URL);
            const protocol = 'https:';
            src = `${protocol}//${url.host}${imageUrl}`;
          }

          inner = `
               <div class="group relative inline-block align-middlepointer-events-none">
                 <img src="${src}" class="w-7 h-7 rounded-full object-cover border-2 border-green-500" alt="Proof" />
               </div>
             `;
        } else if (status === 'check') {
          inner = `
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="inline-block align-middle text-green-500">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
          `;
        } else if (status === 'cross') {
          inner = `
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="inline-block align-middle text-red-500">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          `;
        } else {
          inner = `
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block align-middle text-gray-300 dark:text-gray-600">
              <circle cx="12" cy="12" r="10"></circle>
            </svg>
          `;
        }
        cell.innerHTML = inner;
      }

      return cell;
    }

    function renderGrid() {
      // Don't render real data until we've synced
      if (!isInitialSyncComplete) return;

      chainGridEl.innerHTML = '';

      // Get today's date in local time (no time component)
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Calculate cutoff date (2 days ago)
      const cutoffDate = new Date(today);
      cutoffDate.setDate(today.getDate() - 2);

      for (let i = 0; i < NUM_DAYS; i++) {
        const currentDate = new Date(START_DATE);
        currentDate.setDate(START_DATE.getDate() + i);
        const dateKey = getDateKey(currentDate);

        // Check if this is today
        const dateOnly = new Date(currentDate);
        dateOnly.setHours(0, 0, 0, 0);
        const isToday = dateOnly.getTime() === today.getTime();

        // Check if weekend (Saturday = 6, Sunday = 0)
        const dayOfWeek = currentDate.getDay();
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;

        // Check if compact (older than 2 days)
        // We compare timestamps to be safe
        const isCompact = dateOnly.getTime() < cutoffDate.getTime();

        const row = document.createElement('tr');
        let rowClasses = 'hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors';

        // Add weekend styling
        if (isWeekend) {
          rowClasses = 'bg-blue-50/30 dark:bg-blue-900/10 hover:bg-blue-50 dark:hover:bg-blue-900/20 transition-colors';
        }

        // Add today highlighting (stronger)
        if (isToday) {
          rowClasses = 'bg-yellow-100 dark:bg-yellow-900/30 hover:bg-yellow-200 dark:hover:bg-yellow-900/40 transition-colors ring-2 ring-yellow-400 dark:ring-yellow-600';
        }

        row.className = rowClasses;

        // Date column
        const dateCell = document.createElement('td');
        let dateCellClasses = 'text-sm font-medium text-gray-600 dark:text-gray-400 border-b border-gray-100 dark:border-gray-700';

        if (isCompact) {
          dateCellClasses += ' p-[2px] text-[10px] leading-none'; // Ultra compact
        } else {
          dateCellClasses += ' p-3'; // Normal padding
        }

        // Match the row background
        if (isWeekend) {
          dateCellClasses += ' bg-blue-50/30 dark:bg-blue-900/10';
        }

        if (isToday) {
          dateCellClasses = 'p-3 text-sm font-bold text-yellow-900 dark:text-yellow-200 bg-yellow-100 dark:bg-yellow-900/30 border-b border-gray-100 dark:border-gray-700';
        }

        dateCell.className = dateCellClasses;
        dateCell.textContent = formatDate(currentDate);
        row.appendChild(dateCell);

        // Participant columns
        for (let participantIndex = 0; participantIndex < PARTICIPANTS.length; participantIndex++) {
          const status = getCellStatus(dateKey, participantIndex);
          const imageUrl = getCellImage(dateKey, participantIndex);
          const isUploading = uploadingCells.has(getCellKey(dateKey, participantIndex));
          const cell = renderCell(status, imageUrl, isCompact, isUploading);

          // Check if this cell is editable
          const isEditable = LOCKED_PARTICIPANT === null || LOCKED_PARTICIPANT === participantIndex;
          const hasImage = !!imageUrl;

          // Allow interaction if editable OR if there's an image to view
          if (isEditable || hasImage) {
            // Click opens popup
            cell.onclick = (e) => {
              e.stopPropagation();
              showPopup(cell, dateKey, participantIndex);
            };

            if (isEditable) {
              // Right click upload shortcut (only for editors)
              cell.oncontextmenu = (e) => {
                e.preventDefault();
                pendingUploadTarget = { dateKey, participantIndex };
                fileInput.click();
              };
              // Ensure pointer cursor
              cell.style.cursor = 'pointer';
            } else {
              // Read-only view interactions
              cell.style.cursor = 'zoom-in';
            }

          } else {
            // Fully disabled (Locked and empty)
            cell.className = cell.className.replace('cursor-pointer', 'cursor-not-allowed opacity-50');
            cell.style.cursor = 'not-allowed';
            cell.style.opacity = '0.5';
          }

          row.appendChild(cell);
        }

        chainGridEl.appendChild(row);
      }
    }

    function renderParticipantNames() {
      // Don't render real names until we've synced
      if (!isInitialSyncComplete) return;

      participantHeaders.forEach((header, index) => {
        // Get saved name or default
        const savedName = participantNames.get(`p${index}`);
        const displayName = savedName || PARTICIPANTS[index];

        header.textContent = displayName;

        // Remove skeleton styling
        header.className = header.className.replace(' animate-pulse', '');

        // Set up editability based on lock
        const canEdit = LOCKED_PARTICIPANT === null || LOCKED_PARTICIPANT === index;
        header.contentEditable = canEdit ? 'true' : 'false';
      });
    }

    // --- STATUS UI ---

    function updateStatusUI(status) {
      let title = status;
      let colorClasses = '';

      switch (status) {
        case 'connected':
          title = 'Connected';
          colorClasses = 'bg-green-500';
          break;
        case 'disconnected':
          title = 'Disconnected';
          colorClasses = 'bg-yellow-500';
          break;
        case 'offline':
          title = 'Offline';
          colorClasses = 'bg-gray-400';
          break;
        default:
          title = 'Connectingâ€¦';
          colorClasses = 'bg-yellow-500';
      }

      statusEl.title = title;
      statusEl.className = `absolute top-0 right-0 w-3 h-3 rounded-full transition-colors ${colorClasses}`;
    }

    // --- EVENT LISTENERS ---

    // Handle initial sync
    provider.on('sync', synced => {
      if (synced && !isInitialSyncComplete) {
        isInitialSyncComplete = true;
        renderGrid();
        renderParticipantNames();
      }
    });

    provider.on("status", e => {
      if (navigator.onLine) {
        updateStatusUI(e.status);
      }
    });

    window.addEventListener('offline', () => updateStatusUI('offline'));
    window.addEventListener('online', () => updateStatusUI(provider.status || 'connecting'));

    updateStatusUI(navigator.onLine ? provider.status || 'connecting' : 'offline');

    // Save participant names when edited (only allow editing if not locked or if it's your column)
    participantHeaders.forEach((header, index) => {
      const canEdit = LOCKED_PARTICIPANT === null || LOCKED_PARTICIPANT === index;

      if (!canEdit) {
        header.contentEditable = 'false';
        header.className = header.className + ' opacity-50 cursor-not-allowed';
      } else {
        header.addEventListener('blur', () => {
          const newName = header.textContent.trim();
          if (newName && newName !== PARTICIPANTS[index]) {
            doc.transact(() => {
              participantNames.set(`p${index}`, newName);
            });
          }
        });

        // Prevent newlines in contenteditable
        header.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            header.blur();
          }
        });
      }
    });

    // --- YJS OBSERVERS ---

    chainData.observe(() => {
      if (isInitialSyncComplete) renderGrid();
    });

    chainImages.observe(() => {
      if (isInitialSyncComplete) renderGrid();
    });

    participantNames.observe(() => {
      if (isInitialSyncComplete) renderParticipantNames();
    });

    // Initial render - show skeleton
    renderSkeleton();

  </script>
</body>

</html>